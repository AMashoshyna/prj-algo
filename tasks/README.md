# Задания

## 2016-04-14 - Задание 0 (подготовка к курсу)

- познакомиться с языком Lisp. Начать можно с
  [креш-курса](https://github.com/vseloved/lisp-crash-ru),
  более подробно можно почитать в
  [литературе](https://github.com/vseloved/lisp-crash-ru/blob/master/1-intro.md#Книги-и-руководства)
- если у вас еще нет акаунта на github, создать его
- форкнуть этот репозиторий, создать ветку с именем,
  которое совпадает с вашим username в слеке.
- форкнуть репозиторий, создать ветку с именем,
  который совпадает с вашим username в слеке.
  Создать в этой ветке в этом репозитории в папке `tasks/`
  подпапку с именем вашего username
- на любом языке программирования, который вы знаете,
  написать функцию, которая преобразует целые числа,
  записанные как строка (`string`) в машинное целое число (`integer`)
  (аналог функций `atoi`, `parse_int`, ...)
  Эту функцию записать в файле с именем: `tasks/<ваш username>/task0`.
  Также в комментариях указать, сколько времени вам понадобилось на эту задачу.
  Отправить [pull request](https://help.github.com/articles/using-pull-requests/)
  с этим файлом на проверку.
  Также приветствуются любые дополнительные материалы:
  тесты, скрипты для запуска и проверки этой функции и т.п.
  Пример запуска функции: `parse_int('42') => 42`


## 2016-04-16 - Задание 1

### Логика

Задание 1. Упростите выражения:

```
(or (and x y)
    (and z y))
```

```
(or (and x y)
    (and (not x) y))
```

```
(and (not x)
     (or (not y)
         (not (and x y))))
```

```
(and (not (and (or (and x (not y))
                   (and (not x) y))
               x))
     (not (and (not (or (and x (not y))
                        (and (not x) y)))
               x)))
```

Задание 2. Преобразуйте в выражение, содержащее `if` (c учетом того, что `(if x y z)` — это выражение, которое выдает значение `z`, если `x` — ложь и `y` в ином случае:

```
(or (and (not x) (not y))
    (and x z))
```

Задание 3. Напишите программу, которая печатает таблицу истинности для всех булевых функций и по ходу придумайте названия для каждой из них. Результат работы должен выглядеть примерно так:

```
 X | Y | True | False | AND | ...
---+---+------+-------+-----+----
 T | T |   T  |   F   |  T  | ...
 T | F |   T  |   F   |  F  | ...
...
```

### Множества

Задание 1. Почитайте на досуге [Введение в теорию множеств и комбинаторику](http://lyceum.urfu.ru/study/mat/080118172948.pdf) - главу 1

Задание 2. Нарисуйте диаграммы Венна, которые отображают следующие множества:

- Множество всех слов (A), всех слов, которые заканчиваются на 'а' (B), всех существительных (C), всех имен собственных (D)
- Множество всех цисел (A), всех целых чисел (B), всех рациональных чисел (C), всех иррациональных чисел (D) и всех натуральных чисел (E)
- Множество всех людей (A), всех женщин (B), всех мужчин (C), всех девочек (D), всех мальчиков (E), всех сирот (F), всех людей, состоящих в браке (G), всех детей (H)


### Машинная арифметика

Шестнадцатиричные числа — это еще один вариант представления чисел на ряду с десятичными и двоичными. Они используют цифры от 0 до 9, а затем от A до F. Одна цифра шестнадцатиричного числа содержит 4 цифры двоичного, т.е. 0000 — это 0, 0001 — это 1, 0010 — это 2, ..., 1000 — это 8, 1001 — это 9, 1010 — А, 1011 — В, 1100 — С, 1101 — D, 1110 — Е и 1111 — F. Эти числа обычно записывают в таком формате: `0x1F` (т.е. `0x` — это префикс, указывающий на то, что число шестнадцатиричное. В данном случае десятичное представление этого числа — 31).

Задание 1. Адреса в памяти компьютера представляются шестнадцатиричными числами. Если у нас 16-разрядная система, то максимально возможный адрес — `2^16—1`? Какое это шестнадцатиричное, двоичное и десятичное число?

Задание 2. Чему равны следующие выражения? Расчитайте вручную (переведя в соответствующие двоичные числа). Не забывайте, что в случае переполнения все, что вылазит за разрядную сетку, просто пропадает. (Операции побитового сдвига вправо `>>` и влево `<<` добавляют один нулевой бит вначале или вконце числа, соответственно сдвигая остальные биты, а операции `&` и или `|` — это побитовый `и` и `или` соответственно).


```
0xCAFEBABE - 0xBAADF00D
```

```
0xDEADC0DE + 0xDEADFACE
```

```
0xCAFEFACE & 0xBAADC0DE
```

```
0xBAADFACE | 0x600DFACE
```

```
0xDEADC0DE >> 1
```

```
0xDEADC0DE << 2
```

### Лисп

Задание 1. Задача FizzBuzz

Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово Fizz, а вместо чисел, кратных пяти — слово Buzz. Если число кратно пятнадцати, то программа должна выводить слово FizzBuzz. Задача может показаться очевидной, но нужно получить наиболее простое и красивое решение.

Вывод этой программы должен выглядеть примерно так:

```
1 2 Fizz 4 ...
```

Это еще одна из популярных задач на собеседованиях. Утверждают, что она отсеивает 95% соискателей :D


## 2016-04-20 - Задание 2

### Задача коммивояжера

Дано n точек. Нужно найти самый короткий маршрут через эти точки, чтобы посетить каждую из них один и только один раз и вернуться в конце в начальную точку (т.е. цикл). 

Есть еще один эвристический метод решения задачи коммивояжера: каждый раз выбирать самый коротое ребро, если оно не создает циклов, а когда у точки появляется и входящий и исходящий путь, удалять эту точку из дальнейшего рассмотрения.

Задание:

1. Является ли это решение корректным или нет и почему? Есть ли какие-то контр-примеры?
2. Реализуйте этот вариант и сравните его работу с простым решением (начать с произвольной точки и выбирать следующей ближайшую к ней точку). Какое из них более корректное? Какое более эффективное (расчитайте сложность этого адгоритма).

Бонус: реализуйте визуализацию для двухмерного случая


## 2016-04-24 - Задание 3

### Умножение матриц

[Определение](https://ru.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86)

Закончите реализацию функции умножения двух матриц, которую мы писали во время занятия

### Задача поиска пика

Уточним определение: пик — это элемент массива, все соседи которого не больше его. Для вектора — это элемент, у которого есть правый и левый сосед и они не меньше его. Для матрицы это элемент, у которого сосеби справа, слева, снизу и сверху не меньше его. Крайние элементы мы не рассматриваем в качестве кандидатов на пик.

Задание: Реализуйте наивный алогритм (полным перебором), который находит хотя бы один пик в одномерном и двухмерном массиве.

Бонус: реализуйте алгоритм, который находит пик в массиве любой размерности.


## 2016-04-27 - Задание 4

### Задача поиска пика (продолжение)

Задание: Реализуйте рекурсивный алгоритм поиска пика для двумерного массива.

Бонус: упростите рекурсивную функцию поиска пика (подсказка: это можно сделать за счет передачи параметров `beg` и `end` в рекурсивный вызов —
тогда можно будет ограничиться одним базовым случаем, как и в итеративном варианте.

### Бинарный поиск

Задание 1. Закончите реализацию функции бинарного поиска, которую мы писали во время занятия

Задание 2. Покажите, что при выполнении проверки на равенство текущей средней точки искомому элементу, в среднем минимум в половине случаев нам все равно придется дойти до последней итерации алгоритма. При каких условиях это число будет равно половине, а при каких больше?
