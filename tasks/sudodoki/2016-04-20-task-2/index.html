<!DOCTYPE html>
<!--
  ;Дано n точек. Нужно найти самый короткий маршрут через эти точки, чтобы посетить каждую из них один и только один раз и вернуться в конце в начальную точку (т.е. цикл).

  ;Есть еще один эвристический метод решения задачи коммивояжера: каждый раз выбирать самый коротое ребро, если оно не создает циклов, а когда у точки появляется и входящий и исходящий путь, удалять эту точку из дальнейшего рассмотрения.

  ;1. Является ли это решение корректным или нет и почему? Есть ли какие-то контр-примеры?
  ;2. Реализуйте этот вариант и сравните его работу с простым решением (начать с произвольной точки и выбирать следующей ближайшую к ней точку). Какое из них более корректное? Какое более эффективное (расчитайте сложность этого адгоритма).

  ;Бонус: реализуйте визуализацию для двухмерного случая
-->
<html>
  <head>
    <meta charset="utf-8">
    <title>Registration form</title>
    <style>
      * {
        box-sizing: border-box;
      }
      html, body {
        height: 100%;
      }
      canvas {
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <canvas id="stage" width="400" height="400"></canvas>
    <script>
        const getRandom = (lower = 0, upper = 100) => lower + Math.floor(Math.random() * upper)
        const times = (length) => Array.apply(Array, { length })
        const generatePoints = (n, dimensions = 2) =>
          times(n).map((_, i) => {
            return dimensions === 1 ?
              {id: i, coord: getRandom()}
              : {id: i, coord: times(dimensions).map(_ => getRandom())}
          })

        const distance = ({coord: [x1, y1]}, {coord: [x2, y2]}) =>
          Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))

        const generateVertices = (points) =>
          points.reduce((memo, initialPoint) => {
            return memo.concat(points.filter((point) => point !== initialPoint).map((anotherPoint) => ({
              nodes: [initialPoint.id, anotherPoint.id],
              distance: distance(initialPoint, anotherPoint)
            })));
          }, [])
        var i = 0;
        kickOff = (points = generatePoints(5)) => {
          const vertices = generateVertices(points)
          const drawingStack = [];
          const draw = () => {
            const {takenVertices, availableVertices} = drawingStack.shift();
            const canvas = document.getElementById('stage');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            takenVertices.forEach(({nodes}) => {
              const fromP = points.find(({id}) => id === nodes[0])
              const toP = points.find(({id}) => id === nodes[1])
              ctx.beginPath();
              ctx.strokeStyle = '#0F0';
              ctx.moveTo(fromP.coord[0], fromP.coord[1])
              ctx.lineTo(toP.coord[0], toP.coord[1]);
              ctx.stroke();
            })
            availableVertices.forEach(({nodes}) => {
              const fromP = points.find(({id}) => id === nodes[0])
              const toP = points.find(({id}) => id === nodes[1])
              ctx.beginPath();
              ctx.strokeStyle = '#888';
              ctx.moveTo(fromP.coord[0], fromP.coord[1])
              ctx.lineTo(toP.coord[0], toP.coord[1]);
              ctx.stroke();
            })
            points.forEach(({coord: [x, y]}) => {
              ctx.beginPath();
              ctx.strokeStyle = 'red';
              ctx.fillStyle = 'red';
              ctx.strokeRect(x, y, 2, 2);
              ctx.stroke();
            })
            if (drawingStack.length) {
              setTimeout(draw, 2000);
            }

          }
          const step = (takenVertices, availableVertices, pointDictionary) => {
            drawingStack.push({takenVertices, availableVertices});
            if (!availableVertices.length) { return {takenVertices, pointDictionary, points};}
            let willBeTaking = availableVertices.sort(function (thisV, otherV) { return thisV.distance - otherV.distance})[0];
            willBeTaking.nodes.forEach((id) => pointDictionary[id] = (pointDictionary[id] || 0) + 1);
            let newTakenVertices = takenVertices.concat(willBeTaking);
            // TODO: Fix this condition
            let newAvailableVertices = availableVertices.filter(({nodes}) => {
              return !willBeTaking.nodes.every((node) => nodes.includes(node)) &&
                pointDictionary[nodes[0]] + pointDictionary[nodes[1]] <= 2
            });
            return step(newTakenVertices, newAvailableVertices, pointDictionary)
          }
          let result = step([], vertices, points.reduce((memo, {id}) => {
            memo[id] = 0;
            return memo;
          }, {}));
          draw()
          return result;
        }
        var predef = [
          {
            "id": 0,
            "coord": [
              40,
              150
            ]
          },
          {
            "id": 1,
            "coord": [
              20,
              80
            ]
          },
          {
            "id": 2,
            "coord": [
              100,
              10
            ]
          },
          {
            "id": 3,
            "coord": [
              50,
              150
            ]
          },
          {
            "id": 4,
            "coord": [
              87,
              5
            ]
          }
        ]
        const {takenVertices} = kickOff(predef);
        console.log('Result: ', takenVertices.map(({nodes}) => `${nodes[0]} - ${nodes[1]}`))
    </script>
  </body>
</html>
